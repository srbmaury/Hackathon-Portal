name: PR Summary Generator

on:
  pull_request:
    types: [opened, synchronize, reopened]
  push:
    branches-ignore:
      - main
      - master

jobs:
  generate-summary:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for better diffs

      - name: Setup base branch
        id: base
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            BASE_REF="${{ github.event.pull_request.base.ref }}"
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            # Try to get base ref from context, fallback to main
            BASE_REF="${{ github.base_ref }}"
            if [ -z "$BASE_REF" ]; then
              BASE_REF="main"
            fi
            BASE_SHA="origin/$BASE_REF"
          fi
          
          # Fetch all branches to ensure we have the base
          git fetch origin --depth=1 || true
          git fetch origin "$BASE_REF" --depth=1 || true
          
          echo "ref=$BASE_REF" >> $GITHUB_OUTPUT
          echo "sha=$BASE_SHA" >> $GITHUB_OUTPUT
          echo "âœ… Base branch: $BASE_REF (SHA: $BASE_SHA)"

      - name: Get PR number
        id: pr
        run: |
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            echo "number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          else
            # For push events, find the PR number
            PR_NUMBER=$(gh pr list --head ${{ github.ref_name }} --json number --jq '.[0].number' 2>/dev/null || echo "")
            if [ -z "$PR_NUMBER" ]; then
              echo "No PR found for this branch. Skipping comment updates."
              echo "number=" >> $GITHUB_OUTPUT
            else
              echo "number=$PR_NUMBER" >> $GITHUB_OUTPUT
            fi
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Summary
        id: summary
        run: |
          set +e  # Don't exit on error
          
          BASE_REF="${{ steps.base.outputs.ref }}"
          BASE_SHA="${{ steps.base.outputs.sha }}"
          
          # Use merge-base to find common ancestor, fallback to base ref
          MERGE_BASE=$(git merge-base HEAD "$BASE_SHA" 2>/dev/null || echo "$BASE_SHA")
          
          # Verify MERGE_BASE exists, if not use HEAD~1 as fallback
          if ! git rev-parse --verify "$MERGE_BASE" >/dev/null 2>&1; then
            MERGE_BASE="HEAD~1"
            if ! git rev-parse --verify "$MERGE_BASE" >/dev/null 2>&1; then
              MERGE_BASE="HEAD"
            fi
          fi
          
          # Get statistics with error handling - use two-dot for commits, three-dot for diff
          CHANGED_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | wc -l | tr -d ' ')
          CHANGED_FILES=${CHANGED_FILES:-0}
          
          TOTAL_COMMITS=$(git rev-list --count "$MERGE_BASE"..HEAD 2>/dev/null || echo "0")
          TOTAL_COMMITS=${TOTAL_COMMITS:-0}
          
          ADDITIONS=$(git diff --numstat "$MERGE_BASE" HEAD 2>/dev/null | awk '{sum+=$1} END {print sum+0}')
          ADDITIONS=${ADDITIONS:-0}
          
          DELETIONS=$(git diff --numstat "$MERGE_BASE" HEAD 2>/dev/null | awk '{sum+=$2} END {print sum+0}')
          DELETIONS=${DELETIONS:-0}
          
          # Get recent commits (last 5 only)
          RECENT_COMMITS=$(git log --oneline "$MERGE_BASE"..HEAD 2>/dev/null | head -5)
          RECENT_COMMITS=${RECENT_COMMITS:-"No commits found"}
          
          # Categorize changed files
          TEST_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | grep -E "(test|spec)" | wc -l | tr -d ' ')
          TEST_FILES=${TEST_FILES:-0}
          
          COMPONENT_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | grep -E "(components|pages)" | wc -l | tr -d ' ')
          COMPONENT_FILES=${COMPONENT_FILES:-0}
          
          API_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | grep -E "api/" | wc -l | tr -d ' ')
          API_FILES=${API_FILES:-0}
          
          CONFIG_FILES=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | grep -E "(\.yml|\.yaml|\.json|config)" | wc -l | tr -d ' ')
          CONFIG_FILES=${CONFIG_FILES:-0}
          
          # Get file list (max 10 files, formatted as list)
          CHANGED_FILE_LIST=$(git diff --name-only "$MERGE_BASE" HEAD 2>/dev/null | head -10 | while read file; do [ -n "$file" ] && echo "- \`$file\`"; done)
          if [ -z "$CHANGED_FILE_LIST" ]; then
            CHANGED_FILE_LIST="- No files changed"
          fi
          
          set -e  # Re-enable error exit
          
          # Generate concise summary
          cat > summary.md << EOF
          ## ğŸ“Š PR Summary
          
          **ğŸ“ˆ Stats:** \`$CHANGED_FILES\` files changed | \`+$ADDITIONS\` / \`-$DELETIONS\` lines | \`$TOTAL_COMMITS\` commits
          
          **ğŸ“¦ Changes:**
          - ğŸ§ª Tests: \`$TEST_FILES\` files
          - ğŸ¨ Components/Pages: \`$COMPONENT_FILES\` files  
          - ğŸ”Œ API: \`$API_FILES\` files
          - âš™ï¸ Config: \`$CONFIG_FILES\` files
          
          **ğŸ“ Recent Commits:**
          \`\`\`
          $RECENT_COMMITS
          \`\`\`
          
          **ğŸ“ Key Files Changed:**
          $CHANGED_FILE_LIST
          $([ "$CHANGED_FILES" -gt 10 ] && echo "\n_... and $((CHANGED_FILES - 10)) more files_")
          
          ---
          _Auto-updated â€¢ Tests running..._
          EOF
          
          # Ensure file exists
          if [ ! -f summary.md ]; then
            echo "## ğŸ“Š PR Summary" > summary.md
            echo "" >> summary.md
            echo "**âš ï¸ Unable to generate detailed summary. Check workflow logs for details.**" >> summary.md
            echo "" >> summary.md
            echo "---" >> summary.md
            echo "_Auto-updated â€¢ Tests running..._" >> summary.md
          fi
          
          # Save for next step
          cat summary.md > $GITHUB_STEP_SUMMARY

      - name: Find existing comment
        id: find-comment
        if: steps.pr.outputs.number != ''
        uses: peter-evans/find-comment@v2
        with:
          issue-number: ${{ steps.pr.outputs.number }}
          comment-author: 'github-actions[bot]'
          body-includes: 'ğŸ“Š PR Summary'

      - name: Update or Create PR Comment
        if: steps.pr.outputs.number != ''
        id: create-comment
        uses: peter-evans/create-or-update-comment@v3
        with:
          issue-number: ${{ steps.pr.outputs.number }}
          comment-id: ${{ steps.find-comment.outputs.comment-id }}
          body-path: summary.md
          edit-mode: replace

      - name: Run Backend Tests
        working-directory: backend
        run: |
          npm ci
          npm test
        continue-on-error: true

      - name: Generate Test Coverage
        working-directory: backend
        run: |
          # Run coverage with --bail=false to ensure all tests run and coverage is generated even if some fail
          npx vitest run --coverage --bail=0 || true
          # Verify coverage file was created
          if [ -f coverage/coverage-summary.json ]; then
            echo "âœ… Coverage file generated successfully"
            ls -lh coverage/coverage-summary.json
            # Show a preview of the coverage
            jq '.total.lines.pct' coverage/coverage-summary.json 2>/dev/null || echo "Could not read coverage percentage"
          else
            echo "âš ï¸ Coverage file NOT found after generation"
            echo "Contents of coverage directory:"
            ls -la coverage/ 2>/dev/null || echo "Coverage directory does not exist"
            # Try to find any coverage files
            find . -name "*coverage*.json" -type f 2>/dev/null | head -5 || echo "No coverage JSON files found"
          fi
        continue-on-error: true

      - name: Update Summary with Test Results
        if: always()
        run: |
          # Ensure summary.md exists
          if [ ! -f summary.md ]; then
            echo "## ğŸ“Š PR Summary" > summary.md
            echo "" >> summary.md
            echo "**âš ï¸ Summary generation had issues. Check workflow logs.**" >> summary.md
            echo "" >> summary.md
            echo "---" >> summary.md
            echo "_Auto-updated â€¢ Tests running..._" >> summary.md
          fi
          
          # Debug: Check if coverage directory exists and list contents
          echo "Current directory: $(pwd)"
          echo "Checking for coverage files..."
          
          # Check multiple possible locations
          COV_FILE=""
          if [ -f backend/coverage/coverage-summary.json ]; then
            COV_FILE="backend/coverage/coverage-summary.json"
            echo "âœ… Found coverage file at: $COV_FILE"
          elif [ -f ./backend/coverage/coverage-summary.json ]; then
            COV_FILE="./backend/coverage/coverage-summary.json"
            echo "âœ… Found coverage file at: $COV_FILE"
          else
            echo "âš ï¸ coverage-summary.json NOT found"
            if [ -d backend/coverage ]; then
              echo "Backend coverage directory exists, contents:"
              ls -la backend/coverage/ | head -10
            else
              echo "Backend coverage directory NOT found"
            fi
          fi
          
          # Get test results if available (jq is pre-installed on GitHub runners)
          BACKEND_COV="N/A"
          if [ -n "$COV_FILE" ] && [ -f "$COV_FILE" ]; then
            echo "Extracting coverage from $COV_FILE..."
            BACKEND_COV_RAW=$(jq -r '.total.lines.pct' "$COV_FILE" 2>&1)
            echo "Raw coverage value: $BACKEND_COV_RAW"
            if [ -n "$BACKEND_COV_RAW" ] && [ "$BACKEND_COV_RAW" != "null" ] && [ "$BACKEND_COV_RAW" != "" ] && [[ ! "$BACKEND_COV_RAW" =~ ^jq: ]]; then
              BACKEND_COV=$(printf "%.1f" "$BACKEND_COV_RAW" 2>/dev/null || echo "$BACKEND_COV_RAW")
              echo "âœ… Formatted coverage: $BACKEND_COV"
            else
              echo "âŒ Failed to extract coverage from JSON: $BACKEND_COV_RAW"
            fi
          fi
          
          TIMESTAMP=$(date -u +"%H:%M:%S UTC")
          
          # Update summary with test results - use # as delimiter to avoid conflicts with / and |
          if grep -q "_Auto-updated.*Tests running" summary.md 2>/dev/null; then
            sed -i 's#_Auto-updated.*Tests running\.\.\._#âœ… **Tests Completed** | Backend Coverage: `'"$BACKEND_COV"'%` | '"$TIMESTAMP"'#' summary.md
          else
            # If the pattern doesn't exist, append test results
            echo "" >> summary.md
            echo "âœ… **Tests Completed** | Backend Coverage: \`$BACKEND_COV%\` | $TIMESTAMP" >> summary.md
          fi
          
          # Add footer
          echo "" >> summary.md
          echo "---" >> summary.md
          echo "_Last updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")_" >> summary.md

      - name: Find existing comment again
        id: find-comment-again
        if: always() && steps.pr.outputs.number != ''
        uses: peter-evans/find-comment@v2
        with:
          issue-number: ${{ steps.pr.outputs.number }}
          comment-author: 'github-actions[bot]'
          body-includes: 'ğŸ“Š PR Summary'

      - name: Update PR Comment with Test Results
        if: always() && steps.pr.outputs.number != ''
        uses: peter-evans/create-or-update-comment@v3
        with:
          issue-number: ${{ steps.pr.outputs.number }}
          comment-id: ${{ steps.find-comment-again.outputs.comment-id }}
          body-path: summary.md
          edit-mode: replace

